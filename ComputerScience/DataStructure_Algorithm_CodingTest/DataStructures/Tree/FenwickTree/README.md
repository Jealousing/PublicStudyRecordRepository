# 펜윅 트리 (Fenwick Tree)

## 펜윅 트리란
펜윅 트리(Fenwick Tree), 또는 바이너리 인덱스 트리(Binary Indexed Tree)는 구간 합 질의를 빠르게 처리하기 위한 자료구조입니다. 특히, 배열의 한 요소를 업데이트하는 연산과 구간 합을 계산하는 연산을 효율적으로 수행할 수 있습니다. 펜윅 트리는 세그먼트 트리보다 구현이 간단하며, 메모리 사용량도 더 적습니다.

### 펜윅 트리의 구조
펜윅 트리의 구조는 각 요소가 특정 구간의 합을 나타내도록 설계되어 있습니다. 이를 위해 각 인덱스에 대해 모두 동일한 방식으로 처리됩니다. 모든 인덱스에 대해 이진수 표현에서 마지막 1 비트를 제거한 다음에 남은 값을 통해 연산을 수행합니다.

### 펜윅 트리의 작동 원리
* 트리 구축: 주어진 배열에 대한 펜윅 트리를 구축합니다. 이를 위해 각 요소의 위치에 따라 일정한 규칙에 따라 값을 누적하여 트리에 저장합니다.
* 구간 합 계산: 주어진 구간에 대한 합을 계산하기 위해 트리를 탐색합니다. 구간의 끝 인덱스까지 이동하면서 해당하는 트리의 요소들을 더하여 구간 합을 계산합니다.

## 펜윅 트리의 특징
 ### 장점
 * 간단한 구현: 펜윅 트리는 구현이 간단합니다. 각 요소를 트리의 노드로 사용하여 구간 합을 표현할 수 있습니다.
 * 적은 메모리 사용량: 펜윅 트리는 세그먼트 트리보다 더 적은 메모리를 사용합니다. 배열의 크기에 비례하는 메모리를 사용하며, 세그먼트 트리보다 작은 상수 배의 메모리를 사용합니다.

 ### 단점
 * 구간 업데이트의 비효율성: 펜윅 트리는 구간 업데이트를 수행할 때 모든 요소를 한 번에 업데이트하는 것이 아니라 각 요소별로 개별적으로 업데이트해야 합니다. 이로 인해 연속된 구간의 모든 요소를 변경하는 것이 비효율적일 수 있습니다.
 * 다양한 구간 질의 처리의 어려움: 펜윅 트리는 주로 구간 합 질의에 최적화되어 있지만, 다른 종류의 구간 질의를 처리할 때는 추가적인 작업이 필요할 수 있습니다. 최소값이나 최대값을 구하는 등의 경우에는 추가적인 처리가 필요합니다.

## 펜윅 트리의 시간 복잡도
펜윅 트리의 구간 합 질의를 처리하는 시간 복잡도는 O(log N)입니다. 각 연산마다 트리의 높이에 비례하는 노드 수만큼 방문하면 되기 때문에 효율적으로 처리할 수 있습니다.
 
## 펜윅 트리와 세그먼트 트리의 차이점
펜윅 트리와 세그먼트 트리는 모두 구간 합을 효율적으로 계산하기 위한 자료구조입니다. 하지만 몇 가지 중요한 차이점이 있습니다.

* 구현의 복잡성: 펜윅 트리는 구현이 간단합니다. 배열의 각 요소를 트리의 노드로 사용하여 구간 합을 표현할 수 있습니다. 반면에 세그먼트 트리는 보다 복잡한 구현이 필요합니다.
* 메모리 사용량: 펜윅 트리는 배열의 크기에 비례하는 메모리를 사용하며, 상수 배의 메모리를 사용합니다. 세그먼트 트리는 배열의 크기에 상수 배 이상의 메모리를 사용합니다.
* 업데이트 연산의 복잡성: 펜윅 트리는 특정 요소의 값을 업데이트하는 것은 쉽지만, 구간에 속한 모든 요소의 값을 변경하는 것은 더 복잡합니다. 세그먼트 트리는 구간 업데이트 연산을 처리하는 데 보다 효율적입니다.
* 다양한 구간 질의 처리: 펜윅 트리는 주로 구간 합 질의에 최적화되어 있습니다. 반면에 세그먼트 트리는 최소값이나 최대값을 구하는 등의 다른 종류의 구간 질의도 처리할 수 있습니다.

## 펜윅 트리의 구현 방법
펜윅 트리를 구현하는 방법은 간단합니다. 주어진 배열에 대해 트리를 구축하는 과정에서 각 요소의 값을 해당하는 트리의 노드에 더하여 트리를 초기화합니다. 이후 구간 합을 계산하거나 특정 요소의 값을 업데이트할 때는 트리를 탐색하여 필요한 연산을 수행합니다.

## 펜윅 트리 구현
```cpp
#include <iostream>
#include <vector>

using namespace std;

// 펜윅 트리 구현
class FenwickTree 
{
private:
    vector<int> tree; // 트리를 저장하는 배열

public:
    // 펜윅 트리 초기화
    FenwickTree(int n) 
    {
        tree.assign(n + 1, 0); // 1부터 시작하는 인덱스를 사용하기 위해 크기를 n + 1로 설정
    }

    // 특정 인덱스까지의 누적 합 계산
    int query(int idx) 
    {
        int sum = 0;
        while (idx > 0) 
        {
            sum += tree[idx];
            idx -= (idx & -idx); // 다음 구간으로 이동하는 과정
        }
        return sum;
    }

    // 구간 합을 업데이트하는 함수
    void update(int idx, int delta) 
    {
        while (idx < tree.size()) 
        {
            tree[idx] += delta;
            idx += (idx & -idx); // 다음 구간으로 이동하는 과정
        }
    }
};

int main() 
{
    vector<int> input = {3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3}; // 입력 배열
    int n = input.size();

    FenwickTree ft(n); // 펜윅 트리 초기화

    // 입력 배열을 펜윅 트리에 업데이트
    for (int i = 0; i < n; ++i) 
    {
        ft.update(i + 1, input[i]); // 인덱스가 1부터 시작하므로 i + 1
    }

    // 펜윅 트리를 이용한 구간 합 계산
    cout << "1부터 6까지의 구간 합: " << ft.query(6) - ft.query(1 - 1) << endl; // 1부터 6까지의 구간 합 계산

    // 특정 인덱스의 값을 변경하고 구간 합 다시 계산
    ft.update(3, 5); // 인덱스 3의 값을 5로 변경
    cout << "1부터 6까지의 구간 합: " << ft.query(6) - ft.query(1 - 1) << endl; // 1부터 6까지의 구간 합 계산

    return 0;
}
```