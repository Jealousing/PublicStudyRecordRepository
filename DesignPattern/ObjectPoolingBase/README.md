# ObjectPool Pattern

## 기능 설명
 게임에서 많은 오브젝트를 생성하고 파괴하는 과정에는 많은 비용을 소모합니다.
 이 비용을 최소화를 위한 방법 중 하나인 오브젝트를 재사용해서 메모리 사용 성능을 개선하는 오브젝트 풀 패턴을 사용해 보려고 합니다.

 ### 장점
 1. 성능 향상: 미리 생성된 객체들을 사용하므로 객체를 생성하고 소멸하는 데 드는 시간과 리소스 감소.
 2. 메모리 관리: 객체를 미리 생성하고 관리하기 때문에 메모리 관리가 효율적으로 이루어지고, 객체가 필요하지 않은 경우에도 바로 메모리에서 해제되지 않고 풀에 반환되어 재사용된다.
 3. 가비지 컬렉션 호출 감소: 객체 생서 및 소멸이 줄어들어 가비지 컬렉션에 의한 부담을 줄일 수 있다.
 4. 상태 보존: 객체 상태를 보존하기 때문에 초기화와 상태 설정을 반복하지 않아도 된다.

 ### 단점
 1. 복잡성 증가: 오브젝트 풀 패턴은 객체의 생성과 관리를 추가로 처리해야 하기때문에 코드가 더 복잡해질 수 있다.
 2. 메모리 사용: 오브젝트 풀은 객체를 미리 생성하기 때문에 항상 오브젝트 풀에 있는 객체를 사용하지 않기 때문에 메모리 낭비가 발생할 수 있다.
 3. 동기화 필요: 멀티스레드 환경에서 사용할 경우, 여러 스레드가 동시에 객체를 가져다 사용하면 동기화에 문제가 발생할 수 있다.
 4. 객체 생성 비용 무시: 객체의 생성이 저렴한 경우 이점이 작을 수 있다.
 
 제 코드는 유니티 2021버전 이후 추가된 IOobjectPool 기능을 사용하고, Dictionary와 Tuple을 활용한 예시입니다.

## 어려움과 해결책
 학교에서도 배웠던 내용이고 이미 다른 기능 구현을 할때도 사용하고 있었기 때문에 개념자체에 어려운 점은 없었다.

## 느낀 점
 공부하면서 느낀점은 유니티에서는 가비지 컬렉션 발생하는 시점을 직접 제어할 수 없기 때문에라도 자주 생성과 파괴를 반복하는 작업은 오브젝트 풀 처리를 해야 겠다는 생각이 드는 디자인 패턴이였다.

## 추가로 개선하고 싶은 부분
 이제 와서 보자면 제네릭 형식으로 만들어서 필요한 곳마다 편하게 활용하게 변경하면 좋겠다는 생각이 들지만 유니티에서 지원하는 IOobjectPool이 너무 편하게 되어있기 때문에 기능 구현 단계에서는 넘어가기로 했다.
 
## 유튜브
 [![Video Label](http://img.youtube.com/vi/Wva4-o9ud-Y/0.jpg)](https://youtu.be/Wva4-o9ud-Y)
 
