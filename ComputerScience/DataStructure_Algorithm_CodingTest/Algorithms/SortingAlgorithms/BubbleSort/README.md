# 버블 정렬 (Bubble Sort)

## 버블 정렬이란?
 버블 정렬은 인접한 두 요소를 비교하면서 필요한 경우 위치를 교환하여 정렬하는 알고리즘입니다. 이 과정을 반복하여 가장 큰 요소가 배열의 마지막으로 이동하며, 그 다음으로 큰 요소가 그 앞으로 이동하는 방식으로 정렬됩니다.

### 버블 정렬의 동작 원리
1. 배열의 첫 번째 요소부터 시작하여 인접한 두 요소를 비교합니다.
2. 만약 두 요소가 순서대로 있지 않다면 위치를 교환합니다.
3. 배열의 끝까지 도달할 때까지 위의 과정을 반복합니다.
4. 한 번의 반복이 완료되면 가장 큰 요소가 마지막 위치로 이동합니다.
5. 정렬된 부분을 제외하고 위의 과정을 다시 반복하여 두 번째로 큰 요소를 찾습니다.
6. 이를 반복하여 전체 배열이 정렬될 때까지 진행합니다.

## 버블 정렬의 특징
 ### 장점
 * 알고리즘이 단순하여 이해하기 쉽고 구현이 간단합니다.
 * 작은 규모의 데이터에 대해서는 효율적입니다.
 * 정렬된 배열을 입력으로 받을 때 최선의 경우에는 O(n)의 시간 복잡도를 가집니다. (데이터가 이미 정렬되어 있는 경우)
 * 비교 연산만을 사용하기 때문에 정렬 이외의 작업에 비용이 들지 않습니다.

 ### 단점
 * 최악의 경우에는 O(n^2)의 시간 복잡도를 가집니다. (모든 요소를 비교해야 하는 경우)
 * 대량의 데이터에 대해서는 비효율적입니다.
 * 다른 정렬 알고리즘에 비해 성능이 좋지 않습니다. 이는 배열이 이미 정렬되어 있는 경우에도 모든 요소를 비교해야 하기 때문입니다.

## 버블 정렬의 시간 복잡도
 버블 정렬의 시간 복잡도는 최선의 경우, 평균의 경우, 최악의 경우 모두 O(n^2)입니다. 이는 배열의 크기에 따라 이중 반복문이 수행되기 때문입니다.
 
## 예시코드 c++
```cpp
#include <iostream>

using namespace std;

void BubbleSort(int arr[], int n) 
{
    for (int i = 0; i < n - 1; i++) 
    {
        for (int j = 0; j < n - i - 1; j++) 
        {
            if (arr[j] > arr[j + 1]) 
            {
                // 두 요소의 위치를 교환
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

int main() 
{
    int arr[] = {64, 25, 12, 22, 11};
    int n = sizeof(arr) / sizeof(arr[0]);
    BubbleSort(arr, n);
    cout << "Sorted array: \n";
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
    cout << endl;
    return 0;
}
```
 
## 버블 정렬의 사용 예시 & 코딩 테스트 유형
* 주어진 배열의 크기가 작거나 이미 정렬된 데이터가 많은 경우에 사용됩니다.
* 코딩 테스트에서 배열을 정렬해야 할 때 버블 정렬은 간단하고 직관적인 구현으로 인해 자주 사용됩니다.

## 알고리즘 변형
개선된 버블 정렬 (Improved Bubble Sort): 이미 정렬된 부분을 검사하지 않고 정렬이 완료된 배열을 출력하는 방식으로 성능을 향상시킨 알고리즘입니다.

### 개선된 버블 정렬의 예시 코드
```cpp
void ImprovedBubbleSort(int arr[], int n) 
{
    bool isSwap; // 교환 여부를 판단하기 위한 변수

    for (int i = 0; i < n - 1; i++) 
    {
        isSwap = false; // 초기에는 교환이 이루어지지 않았다고 가정

        for (int j = 0; j < n - i - 1; j++) 
        {
            if (arr[j] > arr[j + 1]) 
            {
                // 두 요소의 위치를 교환
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;

                isSwap = true; // 교환이 이루어졌으므로 true로 변경
            }
        }

        // 교환이 이루어지지 않았다면 배열이 이미 정렬된 상태
        if (!isSwap) 
        {
            break;
        }
    }
}
```