# 세그먼트 트리 (Segment Tree)

## 세그먼트 트리란
세그먼트 트리(Segment Tree)는 구간 질의(구간 합, 구간 최소값 등)을 효율적으로 처리하기 위한 자료구조입니다. 구간 질의는 배열 또는 리스트와 같은 시퀀스 데이터 구조에서 특정 구간에 대한 연산을 수행하는 것을 의미합니다. 세그먼트 트리는 이러한 구간 질의를 빠르게 처리할 수 있도록 트리 구조를 활용합니다.

### 세그먼트 트리의 구조
 세그먼트 트리는 전체 데이터 배열을 트리 형태로 나타낸 것입니다. 이진 트리의 형태를 가지며, 각 노드는 배열의 특정 구간에 해당하는 값을 저장합니다. 이를 이용하여 원하는 구간에 대한 질의를 수행합니다. 트리의 리프 노드는 배열의 각 원소에 대응하며, 상위 노드는 하위 노드의 값을 조합하여 특정 구간에 대한 정보를 저장합니다.

### 세그먼트 트리의 작동 원리
* 트리 구축: 주어진 배열에 대한 세그먼트 트리를 구축합니다. 이를 위해 배열의 요소들을 트리의 리프 노드에 저장하고, 상위 노드에는 해당 구간의 합, 최소값 등을 저장합니다.
* 구간 질의 수행: 주어진 구간에 대한 질의를 수행하기 위해 트리를 탐색합니다. 구간 질의를 수행하는 과정에서 트리의 노드들을 방문하며 구간을 나누고, 필요한 연산을 수행합니다. 이때, 구간을 나누는 과정은 트리의 분기를 통해 이루어지며, 구간에 대한 연산은 각 노드가 저장한 값들을 활용하여 계산됩니다.

## 세그먼트 트리의 특징
 
 ### 장점
* 높은 성능: 세그먼트 트리를 이용하면 구간 질의를 빠르게 처리할 수 있습니다. 일반적으로 구간 질의를 처리하는 시간은 O(log N)입니다.
* 메모리 사용량: 세그먼트 트리는 일반적으로 배열의 크기에 대해 상수 배만큼의 메모리를 사용하므로, 메모리 사용량이 증가할 수 있습니다.
* 유연성: 세그먼트 트리는 여러 종류의 구간 질의에 적용할 수 있습니다. 최소값, 최대값, 합 등 다양한 질의를 처리할 수 있습니다.

 ### 단점
* 복잡한 구현: 세그먼트 트리는 구현이 다소 복잡할 수 있습니다. 특히, 초기 트리 구축과 구간 질의를 처리하는 함수를 작성하는 과정이 번거로울 수 있습니다.
* 공간 복잡도: 세그먼트 트리는 입력 배열의 크기에 대해 상수 배만큼의 메모리를 사용하므로, 입력 배열이 매우 큰 경우 메모리 사용량이 증가할 수 있습니다.
* 업데이트 비용: 구간 업데이트 연산의 비용이 높을 수 있습니다. 구간 업데이트 연산을 수행할 때, 해당 구간에 해당하는 모든 노드를 업데이트해야 하기 때문에 시간 복잡도가 높아질 수 있습니다.

## 세그먼트 트리의 활용
* 구간 합: 배열의 특정 구간에 포함된 값들의 합을 계산하는데 사용됩니다.
* 구간 최소값, 최대값: 배열의 특정 구간에 포함된 값들 중 최소값이나 최대값을 찾는데 사용됩니다.
* 구간 업데이트: 배열의 특정 구간에 포함된 값들을 갱신하거나 변경하는 데 사용됩니다.

## 세그먼트 트리의 시간 복잡도
세그먼트 트리는 구간 질의를 빠르게 처리할 수 있는 장점을 갖고 있습니다.    
일반적으로 구간 질의를 처리하는 시간 복잡도는 트리의 높이에 비례하며, 이는 O(log N)의 시간 복잡도를 갖습니다. 이는 트리가 이진 트리로 구성되어 있고, 각 구간 질의마다 트리의 높이에 해당하는 노드 수만큼만 방문하면 되기 때문입니다. 이러한 성질로 인해 세그먼트 트리는 대용량 데이터에 대한 구간 질의를 효율적으로 처리할 수 있습니다.

## 세그먼트 트리의 구현 방법
세그먼트 트리를 구축하는 과정은 전형적으로 재귀함수를 사용한 방법을 사용합니다.    
주어진 배열을 기반으로 트리를 만들기 위해 배열을 반으로 나누고 각 부분 배열에 대해 하위 트리를 생성하는 식으로 진행됩니다. 이 과정에서 배열의 크기가 2의 제곱수가 아닌 경우에는 배열의 크기를 2의 제곱수로 맞추기 위해 추가적으로 원소를 채워야 합니다. 재귀적인 방법을 사용하면 각 단계에서 노드를 탐색하여 해당 구간의 값을 계산하고, 상위 노드에 저장하는 작업을 반복합니다. 이러한 방식으로 구축된 트리는 구간 질의에 효율적으로 대응할 수 있습니다.

## 세그먼트 트리의 구현 코드
```cpp
#include <iostream>
#include <vector>

using namespace std;

// 세그먼트 트리 구현
class SegmentTree 
{
private:
    vector<int> tree; // 트리를 저장하는 배열
    vector<int> arr;  // 입력 배열
    int n;            // 입력 배열의 크기

    // 세그먼트 트리 초기화
    void build(int node, int start, int end) 
    {
        if (start == end) 
        {
            tree[node] = arr[start];
        } 
        else 
        {
            int mid = (start + end) / 2;
            build(2 * node, start, mid);
            build(2 * node + 1, mid + 1, end);
            tree[node] = tree[2 * node] + tree[2 * node + 1]; // 합을 저장
        }
    }

    // 구간 합을 계산하는 함수
    int query(int node, int start, int end, int left, int right) 
    {
        if (right < start || left > end) 
        {
            return 0; // 구간이 현재 노드의 구간과 겹치지 않음
        }
        if (left <= start && right >= end) 
        {
            return tree[node]; // 구간이 현재 노드의 구간을 완전히 포함함
        }
        int mid = (start + end) / 2;
        return query(2 * node, start, mid, left, right) + query(2 * node + 1, mid + 1, end, left, right);
    }

public:
    SegmentTree(vector<int>& input) 
    {
        arr = input;
        n = arr.size();
        tree.resize(4 * n); // 트리 배열의 크기는 입력 배열 크기의 4배로 설정
        build(1, 0, n - 1); // 트리 구축
    }

    // 구간 합하는 함수
    int rangeSumQuery(int left, int right) 
    {
        return query(1, 0, n - 1, left, right);
    }
};

int main() 
{
    vector<int> input = {1, 3, 5, 7, 9, 11};
    SegmentTree st(input);
    
    // 구간 합
    cout << "구간 합 결과: " << st.rangeSumQuery(1, 4) << endl;

    return 0;
}
```