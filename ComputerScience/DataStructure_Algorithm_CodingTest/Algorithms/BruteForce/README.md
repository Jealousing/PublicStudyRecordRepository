# 브루트포스 알고리즘 (Brute Force)

## 브루트포스 알고리즘이란?
 브루트포스 알고리즘은 가능한 모든 경우의 수를 하나씩 검사하여 해답을 찾는 방법입니다. 즉, 모든 가능성을 시도하고 확인함으로써 해결책을 찾는 방법입니다.    
다른 말로는 완전 탐색 알고리즘이라고도 합니다. 이 알고리즘은 무식한 힘으로 모든 가능성을 탐색하여 정확한 답을 찾아냅니다.    
이 방법은 간단하고 직관적이지만, 경우의 수가 많을 경우에는 실행 시간이 매우 오래 걸릴 수 있습니다.

## 브루트포스 알고리즘의 특징
* 가능한 모든 경우의 수를 일일이 확인하여 해답을 찾습니다.
* 모든 경우를 시도하므로 정확한 해를 찾을 수 있습니다.
* 경우의 수가 적을 때는 유용하지만, 경우의 수가 많을 때는 효율성이 떨어질 수 있습니다.
 
## 브루트포스 알고리즘의 단계
 1. **모든 가능한 경우의 수 생성:** 문제의 조건에 따라 가능한 모든 경우의 수를 생성합니다. 이 단계에서는 모든 자료를 탐색하며, 경우의 수를 구조화합니다.
 2. **조건 확인:** 각 경우의 수를 조건에 맞는지 확인합니다. 조건에 맞는 경우만을 남겨둡니다.
 3. **결과 도출:** 조건에 맞는 경우의 수 중에서 최종 결과를 도출합니다.

## 브루트포스 알고리즘의 예시
* **약수의 합 구하기:** 10의 약수가 될 수 있는 모든 자연수를 구조화하고, 10의 약수가 되는 값만을 남겨두는 방식으로 브루트포스 알고리즘을 적용할 수 있습니다. 예를 들어, {1, 2, 3, 4, 5, 6, 7, 8, 9, 10} 중에서 10의 약수는 {1, 2, 5, 10}이므로, 10의 약수의 합은 1 + 2 + 5 + 10 = 18입니다.
* **비밀번호 찾기:** 10자리 비밀번호 자물쇠가 있다고 가정해보겠습니다. 이 자물쇠를 풀기 위해서 브루트포스 방식을 적용한다면 0000000000부터 9999999999까지 모든 수를 대입해서 풀어야 할 것입니다.
* **합이 10억인 두 수 찾기:** 1부터 10억까지의 합을 브루트포스로 구한다면 반복문으로 1부터 10억까지 증가시키면서 계산해야 합니다.


## 브루트포스 알고리즘의 예시 코드 (C++)

아래는 백준에서 풀었던 브루트포스 알고리즘을 사용한 문제의 코드입니다.   
[ [문제링크](https://www.acmicpc.net/problem/2798) / [코드링크](https://github.com/Jealousing/PublicStudyRecordRepository/blob/main/ComputerScience/DataStructure_Algorithm_CodingTest/CodingTest/Baekjoon/BruteForce/2798.cpp) ]

```cpp
﻿#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main()
{
	//카드 3장 , M에 최대한 가까운값
	int N, M;
	int max = 0;
	vector<int> v;
	cin >> N >> M;

	v.resize(N);

	for (int i = 0; i < N; i++)
	{
		cin >> v[i];
	}

	//if( 3장을 더한값 > max && 3장을더한값 <= M)
	for (int i = 0; i < N-1; i++)
	{
		for (int j = i+1; j < N; j++)
		{
			for (int k = j + 1; k < N; k++)
			{
				if (max < v[i] + v[j] + v[k] && v[i] + v[j] + v[k] <= M)
				{
					max = v[i] + v[j] + v[k];
				}
			}
		 }
	}

	cout << max << endl;
	return 0;
}
```